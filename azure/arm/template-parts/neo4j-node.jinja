{#
 # This sub-template creates a collection of VMs, and resources necessary for those VMs,
 # including IP addresses, availability sets, and so on.
 #
 # This is a template snippet and is not valid JSON on its own when expanded, it is intended
 # to be included in the larger clusterTemplate.
 #
 # Intention behind this snippet is to be able to create a node set as either CORE or READ_REPLICA
 # with all dependent resources.
 # 
 # Requires jinja variables:
 #     dbms_mode = (CORE|READ_REPLICA)
 #     count_parameter e.g. "CoreNodes" - the name of the ARM parameter containing the number of
 #     VMs to generate.
 #
 # Note that this template has many ARM parameter/variable dependencies, generally taken from
 # mainTemplate.json and clusterTemplate.json
 #}
 {%
    set safe_dbms_mode = dbms_mode.replace('_', '-').lower()
 %}
{
    {# 
     # DOCS: https://docs.microsoft.com/en-us/azure/virtual-machines/windows/manage-availability#configure-multiple-virtual-machines-in-an-availability-set-for-redundancy 
     # Update domains control how many machines could be restarted/updated.
     # Fault domains control hardware co-location.  Availability sets let us spread our VMs out
     # across these domains so that a power source failure or needed VM upgrade can't interrupt the
     # entire cluster, or even the entire read replica set.
     #}
    "type": "Microsoft.Compute/availabilitySets",
    "name": "[concat(variables('namePrefixes').availabilitySet, '-', '{{safe_dbms_mode}}')]",
    "apiVersion": "2018-06-01",
    "location": "[parameters('Location')]",
    "tags": "[parameters('Neo4JTags')]",
    "properties": {
        "platformUpdateDomainCount": 20,
        "platformFaultDomainCount": 3
    },
    "sku": {
        "name": "Aligned"
    },
    "dependsOn": []
},
{
    "type": "Microsoft.Resources/deployments",
    "name": "IPListConstructor-{{dbms_mode}}",
    "apiVersion": "2017-05-10",
    "dependsOn": [],
    "properties": {
        "mode": "Incremental",
        "templateLink": {
            "uri": "[concat(variables('artifactsBase'), 'generateIPList.json')]",
            "contentVersion": "1.0.0.0"
        },
        "parameters": {
            "name": {
                "value": "{{dbms_mode}}"
            },
            "subnetCIDR": {
                {% if dbms_mode == "CORE" %}
                "value": "10.0.1.0/25"
                {% else %}
                "value": "10.0.1.128/25"
                {% endif %}
            },
            "addressCount": {
                "value": "[parameters('{{count_parameter}}')]"
            },
            "ArtifactsBase": {
                "value": "[parameters('ArtifactsBase')]"
            }
        }
    }
},
{
    "type": "Microsoft.Network/publicIPAddresses",
    "name": "[concat(variables('namePrefixes').publicIP, '-', '{{safe_dbms_mode}}', '-', copyIndex())]",
    "apiVersion": "2017-08-01",
    "location": "[parameters('Location')]",
    "properties": {
        "publicIPAllocationMethod": "[parameters('PublicIPAllocationMethod')]",
        "dnsSettings": {
            "domainNameLabel": "[toLower(concat(parameters('ClusterName'), '-', '{{safe_dbms_mode}}-node-', copyIndex()))]"
        }                
    },
    "copy": {
        "name": "ip{{dbms_mode}}CI",
        "count": "[parameters('{{count_parameter}}')]"
    }
},
{
    "type": "Microsoft.Network/networkInterfaces",
    "name": "[concat(variables('namePrefixes').nic, '-', '{{safe_dbms_mode}}', '-', copyIndex())]",
    "apiVersion": "2017-10-01",
    "location": "[parameters('Location')]",
    "tags": "[parameters('Neo4JTags')]",
    "properties": {
        "ipConfigurations": [
            {
                "name": "ipconfig1",
                "properties": {
                    "subnet": {
                        "id": "[concat(variables('resourceIDs').virtualNetwork, '/subnets/', parameters('SubnetName'))]"
                    },
                    "privateIPAllocationMethod": "Dynamic",
                    "publicIPAddress": {
                        "id": "[concat(variables('resourceIDs').publicIP, '-', '{{safe_dbms_mode}}', '-', copyIndex())]"
                    }
                }
            }
        ],
        "dnsSettings": {
            "dnsServers": [],
            "internalDnsNameLabel": "[toLower(concat(parameters('ClusterName'), '-', '{{safe_dbms_mode}}-node-', copyIndex()))]"
        },
        "enableIPForwarding": false,
        "networkSecurityGroup": {
            "id": "[resourceId('Microsoft.Network/networkSecurityGroups', variables('namePrefixes').nsg)]"
        }
    },
    "copy": {
        "name": "nicCI",
        "count": "[parameters('{{count_parameter}}')]"
    },
    "dependsOn": [
        "[concat(variables('resourceIDs').publicIP, '-', '{{safe_dbms_mode}}', '-', copyIndex())]",
        "VirtualNetwork",
        "IPListConstructor-{{dbms_mode}}",
        "[variables('namePrefixes').nsg]"
    ]
}, 
{
    "type": "Microsoft.Compute/virtualMachines",
    "name": "[concat(variables('namePrefixes').vm, '-', '{{safe_dbms_mode}}', '-', copyIndex())]",
    "apiVersion": "2018-04-01",
    "location": "[parameters('Location')]",
    "tags": {
        "provider": "B9442746-5BFF-4E2F-BC90-1F49C5791FAA",
        "neo4jURL": "https://neo4j.com/",
        "licensing": "https://neo4j.com/lp/enterprise-cloud/?utm_content=azure-marketplace",
        "dbms_mode": "{{ dbms_mode }}",
        "neo4j_mode": "cluster",
        "dbms_connector_https_listen_address": "[concat('0.0.0.0:', string(parameters('Neo4jHttpsPort')))]",
        "dbms_connector_http_listen_address": "[concat('0.0.0.0:', string(parameters('Neo4jHttpPort')))]",
        "dbms_connector_bolt_listen_address": "[concat('0.0.0.0:', string(parameters('Neo4jBoltPort')))]",
        "causal_clustering_minimum_core_cluster_size_at_formation": "3",

        {#
         # Gnarly concatenation ahead.   General format we're going for is:
         # node1DNS:5000,node2DNS:5000,node3DNS:5000
         #
         # Note that no matter how many core nodes the cluster has, the initial discovery members of 3 is
         # enough for them to all find themselves.  Also, since min size is 3, doing first 3 is always safe.
         #
         # Pattern for one DNS entry is:
         # concat(parameters('ClusterName'), '-', 'core-node-0')
         #}
        "causal_clustering_initial_discovery_members": "[toLower(concat(parameters('ClusterName'), '-', 'core-node-0:5000,', parameters('ClusterName'), '-', 'core-node-1:5000,', parameters('ClusterName'), '-', 'core-node-2:5000'))]",
        "causal_clustering_discovery_type": "LIST",
        "dbms_connector_bolt_tls_level": "OPTIONAL"
    },
    "properties": {
        "availabilitySet": {
            "id": "[concat(variables('resourceIDs').availabilitySet, '-', '{{safe_dbms_mode}}')]"
        },
        "hardwareProfile": {
            "vmSize": "[parameters('VmSize')]"
        },
        "storageProfile": {
            "imageReference": "[variables('imageReference')]",
            "osDisk": {
                "name": "[concat(variables('namePrefixes').vm, '-', '{{safe_dbms_mode}}', '-', copyIndex(), '-OS')]",
                "createOption": "fromImage",
                "managedDisk": {
                    "storageAccountType": "Standard_LRS"
                }
            },
            "dataDisks": [
                {
                    "lun": 0,
                    "name": "[concat(variables('namePrefixes').vm, '-', '{{safe_dbms_mode}}', '-', copyIndex(), '-Data-0')]",
                    "createOption": "Empty",
                    "managedDisk": {
                        "storageAccountType": "Standard_LRS"
                    },
                    "caching": "None",
                    "diskSizeGB": "[parameters('DataDiskSizeGB')]"
                }
            ]
        },
        "osProfile": {
            "computerName": "[concat(variables('namePrefixes').vm, '-', '{{safe_dbms_mode}}', '-', copyIndex())]",
            "adminUsername": "[parameters('AdminUserName')]",
            "linuxConfiguration": "[variables('authConfig').linuxConfiguration]",
            "secrets": [],
            "adminPassword": "[variables('authConfig').adminPassword]"
        },
        "networkProfile": {
            "networkInterfaces": [
                {
                    "id": "[resourceId('Microsoft.Network/networkInterfaces', concat(variables('namePrefixes').nic, '-', '{{safe_dbms_mode}}', '-', copyIndex()))]"
                }
            ]
        }
    },
    "copy": {
        "name": "vm{{ dbms_mode }}CI",
        "count": "[parameters('{{ count_parameter }}')]"
    },
    "dependsOn": [
        "[concat(variables('resourceIDs').availabilitySet, '-', '{{safe_dbms_mode}}')]",
        "[resourceId('Microsoft.Network/networkInterfaces', concat(variables('namePrefixes').nic, '-', '{{safe_dbms_mode}}', '-', copyIndex()))]"
    ]
},
{
    "type": "Microsoft.Resources/deployments",
    "name": "[concat('ConfigureVM-', variables('namePrefixes').vm, '-', '{{safe_dbms_mode}}', '-', copyIndex())]",
    "apiVersion": "2017-05-10",
    "dependsOn": [
        "[concat('Microsoft.Compute/virtualMachines/', variables('namePrefixes').vm, '-', '{{safe_dbms_mode}}', '-', copyIndex())]"
    ],
    "copy": {
        "name": "vmExtLoop",
        "count": "[parameters('{{ count_parameter }}')]"
    },
    "properties": {
        "mode": "Incremental",
        "templateLink": {
            "uri": "[concat(variables('artifactsBase'), 'scriptTemplate.json')]",
            "contentVersion": "1.0.0.0"
        },
        "parameters": {
            "VmName": {
                "value": "[concat(variables('namePrefixes').vm, '-', '{{safe_dbms_mode}}', '-', copyIndex())]"
            },
            "Location": {
                "value": "[parameters('Location')]"
            },
            "Password": {
                "value": "[parameters('Neo4jPassword')]"
            },
            "ArtifactsBase": {
                "value": "[parameters('ArtifactsBase')]"
            }
        }
    }
}
